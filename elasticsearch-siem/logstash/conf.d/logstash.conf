input {
    syslog {
        id => "audit_in"
        port => 20514
        type => syslog
        add_field => {"log_type" => "PF_Audit_Log"}
    }
    syslog {
        id => "provisioner_in"
        port => 20515
        type => syslog
        add_field => {"log_type" => "PF_Provisioner_Log"}
    }
    syslog {
        id => "directory_in"
        port => 20516
        type => syslog
        add_field => {"log_type" => "PD_Access_Log"}
    }
}

filter{
    #Log4J Pattern
    if([log_type] == "PF_Audit_Log"){
        csv{
            columns => ["long_log_timestamp","event_time","company_name","product_name","trackingid","event_name","subject","ip","app","connectionid","protocol","host_name","role","status","adapterid","description","responsetime","initiator"]
            separator => "| "
        }
        mutate {
            remove_field => "[tags]"
            remove_field => "[message]"
            remove_field => "[long_log_timestamp]"
        }
        geoip {
            source => "ip"
        }

        translate {
            field => "ip"
            destination => "threat_intel"
            fallback => "No"
            dictionary_path => '/etc/logstash/enrichment/AlienVaultIP.yml'
            refresh_behaviour => "replace"
        }

        translate {
            field => "ip"
            destination => "tor_intel"
            fallback => "No"
            dictionary_path => '/etc/logstash/enrichment/TorNodes.yml'
            refresh_behaviour => "replace"
        }
    }

    #Log4J Pattern
    if([log_type] == "PF_Provisioner_Log"){
        csv{
            columns => ["long_log_timestamp","event_time","company_name","product_name","log_type_stamp","pfversion","event_type","cycle_id","channel_id","event_type","source_id","target_id","is_success","non_success_cause"]
            separator => "| "
        }
    }

    if([log_type] == "PD_Access_Log"){

        kv {
            source => "[message]"
            value_split => "="
        }

        grok {
            match => { "message" => "\A%{WORD:ldapType} %{GREEDYDATA}" }
        }

        mutate{
            gsub => [ 
                "filter", '"', ""
            ]
            gsub => [ 
                "dn", '"', ""
            ]
        }

        translate {
            field => "requesterIP"
            destination => "threat_intel"
            fallback => "No"
            dictionary_path => '/etc/logstash/enrichment/AlienVaultIP.yml'
            refresh_behaviour => "replace"
        }

        translate {
            field => "requesterIP"
            destination => "tor_intel"
            fallback => "No"
            dictionary_path => '/etc/logstash/enrichment/TorNodes.yml'
            refresh_behaviour => "replace"
        }

        mutate {
            remove_field => "[message]"
        }
    }
}

output{
    if([log_type] == "PF_Audit_Log"){
        elasticsearch {
            id => "audit_out"
            ssl => true
            ssl_certificate_verification => false
            hosts => ["https://es01:9200","https://es02:9200"]
            index => "pf-audit-logs-%{+YYYY.MM.dd}"
            user => "elastic"
            password => "${ELASTIC_PASSWORD}"
        }
    }
    if([log_type] == "PF_Provisioner_Log"){
        elasticsearch {
            id => "provisioner_out"
            ssl => true
            ssl_certificate_verification => false
            hosts => ["https://es01:9200","https://es02:9200"]
            index => "pf-provisioner-logs-%{+YYYY.MM.dd}"
            user => "elastic"
            password => "${ELASTIC_PASSWORD}"
        }
    }
    if([log_type] == "PD_Access_Log"){
        elasticsearch {
            id => "pd_out"
            ssl => true
            ssl_certificate_verification => false
            hosts => ["https://es01:9200","https://es02:9200"]
            index => "pd-access-logs-%{+YYYY.MM.dd}"
            user => "elastic"
            password => "${ELASTIC_PASSWORD}"
        }
    }
}
